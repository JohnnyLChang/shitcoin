from collections import deque

from . import crypto
from .block import GENESIS
from .crypto import NO_HASH
from .exceptions import InvalidBlock, UTXONotFound, BadSignature


class UTXOSet(dict):
    """ The Unspent Transaction Output Set represents the current spendable
    balances. It maps txids to a dict of index -> Output.

    An example of an UTXO set might look like this:
    {
        8ab26e0f28a...: {
            0: <Output...>
            2: <Output...>
        },
        1b8ae687f2e...: {
            1: <Output...>
        }
    }

    It is basically a dict of transaction IDs to a dict of outputs.
    Some indices might be missing in each transaction, as they have been spent.
    """

    def __init__(self):
        self.current_block = GENESIS

    def remove_utxo(self, txid, index):
        try:
            self[txid].pop(index)
        except:
            raise UTXONotFound()

        # If all outputs of that transactions are now gone, also remove the tx
        if not self[txid]:
            self.pop(txid)

    def apply_transaction(self, tx, verify=False):
        """ Applies a transaction to the UTXO list. If an exception is raised,
        the old utxo set is preserved.

        Args:
            tx(Transaction): The transaction to apply
            verify(bool): If true, signatures are checked

        Raises:
            UTXONotFound: If some input could not be resolved. In that case the
                UTXO set will stay in the previous state.
            BadSignature: If verify was True and some signature failed to check

        Returns:
            Fee of the transaction (money which was destroyed)
        """
        fee = 0
        txid = tx.get_txid()

        # Check all outputs being spent exist and signatures are valid
        for inp in tx.inputs:
            if inp.txid == NO_HASH:  # skip dummy inputs
                continue
            try:
                inp.spent_output = self[inp.txid][inp.index]
            except KeyError:
                raise UTXONotFound()
            if verify and not crypto.verify_sig(txid, inp.spent_output.pubkey,
                                                inp.signature):
                raise BadSignature()

        # Now we are sure, that this will give a valid state, so do it
        for inp in tx.inputs:
            if inp.txid == NO_HASH:  # skip dummy inputs
                continue
            fee += self[inp.txid][inp.index].amount
            self.remove_utxo(inp.txid, inp.index)

        # Add outputs
        txid = tx.get_txid()
        self[txid] = {}
        for i, out in enumerate(tx.outputs):
            fee -= out.amount
            self[txid][i] = out

        return fee

    def revert_transaction(self, tx):
        """ Reverts a transaction.

        Raises:
            UTXONotFound: If some output could not be found. In that case no
                changes are made to the UTXO list.

        Args:
            tx: The transaction to revert
        """
        txid = tx.get_txid()

        # Remove the created outputs
        if txid not in self or len(self[txid]) != len(tx.outputs):
            # Some or all of the outputs were spent, can't reverse the tx
            raise UTXONotFound()
        self.pop(txid)

        # Now readd the outputs spent by the inputs
        for inp in tx.inputs:
            if inp.txid == NO_HASH:  # skip dummy inputs
                continue
            if inp.txid not in self:
                self[inp.txid] = {}
            self[inp.txid][inp.index] = inp.spent_output

    def apply_block(self, block, verify=False):
        """ Apply all transactions of the block to the utxo set.

        Raises:
            UTXONotFound: If some referenced utxos could not be resolved. This
                leaves the utxo set in a half applied state.
            BadSignature: If some signature was wrong.

        Args:
            block: The block to apply
            verify: If True, signatures are checked

        Returns:
            The total money generated by this block
        """
        if block.prev_hash != self.current_block.get_hash():
            raise InvalidBlock('Trying to apply block to wrong parent!')

        total_fee = 0

        # It is possible that some transactions reference outputs, which are
        # created by other transactions is this block, so we need to go over
        # the list until it is empty or all transactions fail
        unchecked_txs = block.txs[:]
        while unchecked_txs:
            resolved_some = False
            for tx in reversed(unchecked_txs):
                try:
                    total_fee += self.apply_transaction(tx, verify)
                except UTXONotFound:
                    # Postpone checking to next iteration
                    continue
                else:
                    unchecked_txs.remove(tx)
                    resolved_some = True

            # If the iteration resolved no transaction, the rest is invalid
            if not resolved_some:
                raise UTXONotFound()

        self.current_block = block

        # We included the coinbase in the fee generation, which should give a
        # negative fee, so a positive amount of currency is generated
        return -total_fee

    def revert_block(self):
        """ Revert the last applied block. This might fail if further
        transactions have been applied after the last block.

        Raises:
            UTXONotFound: If some transaction could not be reversed.
        """
        # We need to iterate over the list until no transactions are left,
        # which can be reverted, as some transactions might spend outputs
        # created by other transactions
        unchecked_txs = self.current_block.txs[:]
        while unchecked_txs:
            resolved_some = False
            for tx in reversed(unchecked_txs):  # reversed to remove items
                try:
                    self.revert_transaction(tx)
                except UTXONotFound:
                    # Postpone checking to next iteration
                    continue
                else:
                    unchecked_txs.remove(tx)
                    resolved_some = True

            # If the iteration resolved no transaction, the rest is invalid
            if not resolved_some:
                raise UTXONotFound()

        self.current_block = self.current_block.get_parent()

    def copy(self):
        """ Copy the UTXO set. The referenced outputs stay the same, so this
        just copies the dictionary structure. This overwrites the copy of dict,
        which copies just the first layer and not the second.

        Note: This completely destroys scalability. An actual currency has
        millions of utxos in memory. """

        new_set = UTXOSet()
        for k, v in self.items():
            new_set[k] = v.copy()

        new_set.current_block = self.current_block
        return new_set

    def move_on_chain(self, to_block):
        """ Walk through the blockchain to create another utxo set. This can
        fail, if further transactions were made on top of the last block.

        Raises:
            UTXONotFound: If reverting or applying some transaction failed.
        """
        # Rewind to common ancestor
        ancestor = self.current_block.find_common_ancestor(to_block)
        while self.current_block != ancestor:
            self.revert_block()

        # Now apply all new blocks
        blocks_to_apply = deque()
        while to_block != ancestor:
            blocks_to_apply.appendleft(to_block)
            to_block = to_block.get_parent()

        for blk in blocks_to_apply:
            self.apply_block(blk, verify=False)
