from collections import deque

from . import crypto
from .crypto import NO_HASH


class InvalidTransaction(Exception):
    pass


class UTXONotFound(InvalidTransaction):
    pass


class BadSignature(InvalidTransaction):
    pass


class UTXOSet(dict):
    """ The Unspent Transaction Output Set represents the current spendable
    balances. It is basically a dict of transaction IDs to a list of outputs.
    The list of outputs is also a dict, as some outputs might have been spent,
    so the list does not need to have continuous indices. """

    def remove_utxo(self, txid, index):
        try:
            self[txid].pop(index)
        except:
            raise UTXONotFound()

        # If all outputs of that transactions are now gone, also remove the tx
        if not self[txid]:
            self.pop(txid)

    def apply_transaction(self, tx, verify=False):
        """ Applies a transaction to the UTXO list. If an exception is raised,
        the old utxo set is preserved.

        Args:
            tx(Transaction): The transaction to apply
            verify(bool): If true, signatures are checked

        Raises:
            UTXONotFound: If some input could not be resolved. In that case the
                UTXO set will stay in the previous state.
            BadSignature: If verify was True and some signature failed to check

        Returns:
            Fee of the transaction (money which was destroyed)
        """
        fee = 0
        txid = tx.get_txid()

        # Check all outputs being spent exist and signatures are valid
        for inp in tx.inputs:
            if inp.txid == NO_HASH:  # skip dummy inputs
                continue
            try:
                inp.spent_output = self[inp.txid][inp.index]
            except KeyError:
                raise UTXONotFound()
            if verify and not crypto.verify_sig(txid, inp.spent_output.pubkey,
                                                inp.signature):
                raise BadSignature()

        # Now we are sure, that this will give a valid state, so do it
        for inp in tx.inputs:
            if inp.txid == NO_HASH:  # skip dummy inputs
                continue
            fee += self[inp.txid][inp.index].amount
            self.remove_utxo(inp.txid, inp.index)

        # Add outputs
        txid = tx.get_txid()
        self[txid] = {}
        for i, out in enumerate(tx.outputs):
            fee -= out.amount
            self[txid][i] = out

        return fee

    def revert_transaction(self, tx):
        """ Reverts a transaction.

        Raises:
            UTXONotFound: If some output could not be found. In that case no
                changes are made to the UTXO list.

        Args:
            tx: The transaction to revert
        """
        txid = tx.get_txid()
        if txid not in self or len(self[txid]) != len(tx.outputs):
            raise UTXONotFound()

        self.pop(txid)

        # Now readd the outputs spent by the inputs
        for inp in tx.inputs:
            if inp.txid == NO_HASH:  # skip dummy inputs
                continue
            if inp.txid not in self:
                self[inp.txid] = {}
            # Note: txids do not include signatures, so we might actually
            # find a different transaction, than we originally had.
            # This means, that applying and reverting a transaction will give
            # a utxo set with the same ownership of money, but maybe different
            # signatures. If the signature scheme gives reproduceable
            # signatures, this does not matter.
            self[inp.txid][inp.index] = inp.spent_output

    def apply_block(self, block, verify=False):
        """ Apply all transactions of the block to the utxo set.

        Raises:
            UTXONotFound: If some referenced utxos could not be resolved. This
                leaves the utxo set in a half applied state.
            BadSignature: If some signature was wrong.

        Args:
            block: The block to apply
            verify: If True, signatures are checked

        Returns:
            The total money generated by this block
        """
        # It is possible that some transactions reference outputs, which are
        # created by other transactions is this block, so we need to go over
        # the list until it is empty or all transactions fail
        total_fee = 0

        unchecked_txs = block.txs[:]
        while unchecked_txs:
            resolved_some = False
            for tx in reversed(unchecked_txs):
                try:
                    total_fee += self.apply_transaction(tx, verify)
                except UTXONotFound:
                    # Postpone checking to next iteration
                    continue
                else:
                    unchecked_txs.remove(tx)
                    resolved_some = True

            # If the iteration resolved no transaction, the rest is invalid
            if not resolved_some:
                raise UTXONotFound()

        # We included the coinbase in the fee generation, which should give a
        # negative fee, so a positive money generated
        return -total_fee

    def revert_block(self, block):
        # We need to iterate over the list until no transactions are left,
        # which can be reverted, as some transactions might spend outputs
        # created by other transactions
        unchecked_txs = block.txs[:]
        while unchecked_txs:
            resolved_some = False
            for tx in reversed(unchecked_txs):
                try:
                    self.revert_transaction(tx)
                except UTXONotFound:
                    # Postpone checking to next iteration
                    continue
                else:
                    unchecked_txs.remove(tx)
                    resolved_some = True

            # If the iteration resolved no transaction, the rest is invalid
            if not resolved_some:
                raise UTXONotFound()

    def copy(self):
        """ Copy the UTXO set. The referenced outputs stay the same, so this
        just copies the dictionary structure. This overwrites the copy of dict,
        which copies just the first layer and not the second.

        Note: This completely destroys scalability. An actual currency has
        millions of utxos in memory. """

        new_set = UTXOSet()
        for k, v in self.items():
            new_set[k] = v.copy()

        return new_set

    def move_on_chain(self, from_block, to_block):
        """ Walk through the blockchain to create another utxo set. """
        # Rewind to common ancestor
        ancestor = from_block.find_common_ancestor(to_block)
        while from_block != ancestor:
            self.revert_block(from_block)
            from_block = from_block.get_parent()

        # Now apply all new blocks
        blocks_to_apply = deque()
        while to_block != ancestor:
            blocks_to_apply.appendleft(to_block)
            to_block = to_block.get_parent()

        for blk in blocks_to_apply:
            self.apply_block(blk, verify=False)
